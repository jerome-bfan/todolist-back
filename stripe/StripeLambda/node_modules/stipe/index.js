var net = require('net');
var path = require('path');
var extend = require('util')._extend;
var InotifyR = require('./lib/inotify-recursive.js');

function nullDummy() {}
function logDummy(err) {console.log('Error: ' + err)}
function trueDummy() {return true}
function trigDummy(event, callback) {callback(null, JSON.stringify(event.file))}

function Watch(root, settings) {
  var self = this;
  settings = settings || {};
  this.settings = settings;

  settings.filter = settings.filter || trueDummy;
  settings.attach = settings.attach || trueDummy;

  var base = root[root.length - 1] !== '/' ? path.dirname(root) : root;
  var file = root[root.length - 1] !== '/' ? path.basename(root) : undefined;

  var Watcher = new InotifyR.Watcher(base, settings);

  Watcher.on('touch', function(file) {
    if(settings.debug) {
      console.log('touch:'+file);
    }
    settings.data({event: Watch.TOUCH, file: file});
  })

  Watcher.on('mkdir', function(file) {
    if(settings.debug) {
      console.log('mkdir:'+file);
    }
    settings.data({event: Watch.MKDIR, file: file});
  })

  Watcher.on('rm', function(file) {
    if(settings.debug) {
      console.log('rm:'+file);
    }
    settings.data({event: Watch.RM, file: file});
  })

  Watcher.on('rmdir', function(file) {
    if(settings.debug) {
      console.log('rmdir:'+file);
    }
    settings.data({event: Watch.RMDIR, file: file});
  })
}

Watch.TOUCH = 1<<0;
Watch.MKDIR = 1<<1;
Watch.RM = 1<<2;
Watch.RMDIR = 1<<3;

function SubmissionClient(params) {
  var self = this;

  this.unix = params.unix;
  this.host = params.host;
  this.port = params.port;
  this.peers = {};
  this.connect();

  if(!this.unix) {
    console.log('Submission client ' + params.unix);

    setInterval(function() {
      if(!self.client) {
        self.connect();
      }
    }, 5*1000);
  } else {
    console.log('Submission client ' + params.host + ':' + params.port);
  }
}

SubmissionClient.prototype.connect = function() {
  var self = this, host = this.host, port = this.port;
  this.client = new net.Socket();
  console.log('Submission client connect:'+this.unix);

  if(this.unix) {
    this.client.connect(this.unix, function() {
      console.log('Connected to ' + self.unix);
    })
  } else {
    this.client.connect(port, host, function() {
      console.log('Connected to ' + host + ':' + port);
    })
  }

  this.client.on('data', function(data) {
    console.log('Received: ' + data);
  })

  this.client.on('error', function() {
    if(self.client) {
      console.log('Connection closed');
      self.client.destroy();
      self.client = undefined;
    }
  })

  this.client.on('close', function() {
    if(self.client) {
      console.log('Connection error');
      self.client.destroy();
      self.client = undefined;
    }
  })
}

function Stipe(settings) {
  settings = settings || {};
  this.match = settings.match;
  this.root = this.match.split('%s') [0];

  settings.trigger = settings.trigger || trigDummy;
  settings.error = settings.error || nullDummy;

  console.log('Settings:'+JSON.stringify(settings));

  if(settings.client) {
    var client = settings.client;

    if(client.unix) {
      var subclient = new SubmissionClient({
        unix: client.unix
      })
    } else {
      var subclient = new SubmissionClient({
        host: client.host || '127.0.0.1',
        port: client.port,
        retry: client.retry || 5
      })
    }
  }

  extend(settings, {
    match: new RegExp(settings.match.split('%s').join('[\\w\.-]+')),
    data: function(event) {
      settings.trigger(event, function(err, data) {
        if(settings.client) {
          if(!subclient.client) {
            console.log('client err: ' + err);
            settings.error(500, data);
            return;
          }

          subclient.client.write(data, function(serr) {
            if(serr) {
              console.log('client write err: ' + serr);
              settings.error(serr, data);
            }
          })
        }
      })
    }
  })

  var watch = new Watch(this.root, settings);
}

module.exports = Stipe;
